"""
FIFO资金追踪器核心模块
实现先进先出原则的资金流向追踪
"""

from collections import deque
from typing import Tuple, Dict, Any, Optional
import pandas as pd

from config import Config
from utils.logger import audit_logger


class FIFO资金追踪器:
    """
    FIFO资金追踪器
    
    实现先进先出原则的资金流向追踪，用于审计分析。
    
    Attributes:
        个人余额 (float): 个人资金池余额
        公司余额 (float): 公司资金池余额
        投资产品资金池 (dict): 投资产品资金池信息
        资金流入队列 (deque): FIFO资金流入队列
        已初始化 (bool): 是否已初始化
        累计挪用金额 (float): 累计挪用金额
        累计垫付金额 (float): 累计垫付金额
        累计已归还公司本金 (float): 累计已归还公司本金
        累计非法所得 (float): 累计非法所得
        总计个人分配利润 (float): 总计个人分配利润
        总计公司分配利润 (float): 总计公司分配利润
    """
    
    def __init__(self):
        """初始化FIFO资金追踪器"""
        # 个人资金池余额
        self.个人余额 = 0.0
        # 公司资金池余额
        self.公司余额 = 0.0
        # 投资产品资金池字典
        self.投资产品资金池 = {}
        # 资金流入FIFO队列，存储(金额, 类型, 时间)
        self.资金流入队列 = deque()
        # 行为分析器（保持累计状态）
        from .behavior_analyzer import BehaviorAnalyzer
        self.行为分析器 = BehaviorAnalyzer()
        # 是否已初始化
        self.已初始化 = False
        # 累计挪用金额（个人使用公司资金，包括投资挪用）
        self.累计挪用金额 = 0.0
        # 累计垫付金额（公司使用个人资金）
        self.累计垫付金额 = 0.0
        # 累计已归还公司本金（通过投资产品赎回归还的公司本金）
        self.累计已归还公司本金 = 0.0
        # 累计非法所得（投资收益中的非法部分）
        self.累计非法所得 = 0.0
        # 总计个人分配利润
        self.总计个人分配利润 = 0.0
        # 总计公司分配利润
        self.总计公司分配利润 = 0.0
        
        # 用于跟踪行为分析器累计值的增量（避免覆盖投资挪用）
        self._上次行为分析器挪用金额 = 0.0
        self._上次行为分析器垫付金额 = 0.0
        
        # 投资产品交易记录
        self.投资产品交易记录 = []
        
        audit_logger.debug("FIFO资金追踪器初始化完成")
    
    def 格式化数值(self, 数值: float) -> float:
        """
        格式化数值，避免科学计数法显示，处理极小值
        
        Args:
            数值: 需要格式化的数值
            
        Returns:
            格式化后的数值
        """
        return Config.format_number(数值)
    
    def 初始化余额(self, 初始余额: float, 余额类型: str = '公司') -> None:
        """
        初始化余额，默认设为公司余额
        
        Args:
            初始余额: 初始余额金额
            余额类型: 余额类型（'个人' 或 '公司'）
        """
        if not self.已初始化 and 初始余额 > 0:
            if 余额类型 == '公司':
                self.公司余额 = 初始余额
                self.资金流入队列.append((初始余额, '公司', None))
            else:
                self.个人余额 = 初始余额
                self.资金流入队列.append((初始余额, '个人', None))
            self.已初始化 = True
            
            # audit_logger.info(f"初始化余额: {初始余额:,.2f} (设为{余额类型}余额)")
    
    def 处理资金流入(self, 金额: float, 资金属性: str, 交易日期: Optional[pd.Timestamp]) -> Tuple[float, float, str]:
        """
        处理资金流入，按FIFO原则分配
        
        Args:
            金额: 流入金额
            资金属性: 资金属性描述
            交易日期: 交易日期
            
        Returns:
            (个人占比, 公司占比, 行为性质)
        """
        if 金额 <= 0:
            return 0, 0, ""
        
        # 判断资金属性类型
        资金属性_str = str(资金属性).strip()
        
        if Config.is_personal_fund(资金属性):
            # 个人资金
            self.个人余额 += 金额
            self.资金流入队列.append((金额, '个人', 交易日期))
            # audit_logger.log_transaction(
            #     row_idx=0,  # 这里需要传入实际的行索引
            #     transaction_type="资金流入",
            #     amount=金额,
            #     fund_attribute=资金属性,
            #     personal_ratio=1.0,
            #     company_ratio=0.0,
            #     behavior=f"个人资金流入：{金额:,.2f}"
            # )
            return 1.0, 0.0, f"个人资金流入：{金额:,.2f}"  # 100%个人
            
        elif Config.is_company_fund(资金属性):
            # 公司资金
            self.公司余额 += 金额
            self.资金流入队列.append((金额, '公司', 交易日期))
            # audit_logger.log_transaction(
            #     row_idx=0,
            #     transaction_type="资金流入",
            #     amount=金额,
            #     fund_attribute=资金属性,
            #     personal_ratio=0.0,
            #     company_ratio=1.0,
            #     behavior=f"公司资金流入：{金额:,.2f}"
            # )
            return 0.0, 1.0, f"公司资金流入：{金额:,.2f}"  # 100%公司
            
        else:
            # 其他情况，按当前余额比例分配
            total_balance = self.个人余额 + self.公司余额
            if total_balance == 0:
                # 如果总余额为0，按默认规则处理
                audit_logger.warning(f"资金池为空，收到{金额:,.2f}，按默认规则处理")
                # 默认按1:1分配
                个人金额 = 金额 / 2
                公司金额 = 金额 / 2
                self.个人余额 += 个人金额
                self.公司余额 += 公司金额
                self.资金流入队列.append((个人金额, '个人', 交易日期))
                self.资金流入队列.append((公司金额, '公司', 交易日期))
                return 0.5, 0.5, f"混合资金流入：个人{个人金额:,.2f}，公司{公司金额:,.2f}"
            else:
                个人占比 = self.个人余额 / total_balance
                公司占比 = self.公司余额 / total_balance
                个人金额 = 金额 * 个人占比
                公司金额 = 金额 * 公司占比
                self.个人余额 += 个人金额
                self.公司余额 += 公司金额
                self.资金流入队列.append((个人金额, '个人', 交易日期))
                self.资金流入队列.append((公司金额, '公司', 交易日期))
                return 个人占比, 公司占比, f"混合资金流入：个人{个人金额:,.2f}，公司{公司金额:,.2f}"
    
    def 处理资金流出(self, 金额: float, 资金属性: str, 交易日期: Optional[pd.Timestamp]) -> Tuple[float, float, str]:
        """
        处理资金流出，按FIFO原则分配
        
        Args:
            金额: 流出金额
            资金属性: 资金属性描述
            交易日期: 交易日期
            
        Returns:
            (个人占比, 公司占比, 行为性质)
        """
        if 金额 <= 0:
            return 0, 0, ""
        
        # 检查是否为投资产品申购
        if Config.is_investment_product(资金属性):
            # 投资产品申购，按FIFO原则处理
            个人占比, 公司占比, 行为性质 = self._处理投资资金流出(金额, 资金属性, 交易日期)
            
            # 更新投资产品资金池
            self._更新投资产品资金池(资金属性, 金额, 个人占比, 公司占比)
            
            前缀 = 资金属性.split('-')[0]
            return 个人占比, 公司占比, f"{前缀}申购-{资金属性}：{行为性质}"
        else:
            return self._处理普通资金流出(金额, 资金属性, 交易日期)
    
    def _处理普通资金流出(self, 金额: float, 资金属性: str, 交易日期: Optional[pd.Timestamp]) -> Tuple[float, float, str]:
        """处理普通资金流出"""
        if 金额 <= 0:
            return 0, 0, ""
        
        # 检查是否有足够的资金
        total_available = self.个人余额 + self.公司余额
        if total_available <= 0:
            audit_logger.warning(f"资金池已空，无法支出{金额:,.2f}")
            return 0, 0, f"资金池已空，无法支出{金额:,.2f}"
        
        # 记录原始交易金额
        原始金额 = 金额
        实际扣除金额 = min(金额, total_available)
        资金缺口 = 金额 - 实际扣除金额
        
        # 添加误差容忍度，避免浮点数精度问题导致的虚假警告
        if 资金缺口 > Config.BALANCE_TOLERANCE:  # 使用0.01元容忍度，避免尾差问题
            audit_logger.warning(f"资金不足! 需要{金额:,.2f}, 可用{total_available:,.2f}，实际扣除{实际扣除金额:,.2f}，资金缺口{资金缺口:,.2f}")
        
        # 修复：如果FIFO队列为空但余额不为空，重新构建队列
        if len(self.资金流入队列) == 0 and total_available > 0:
            audit_logger.warning("FIFO队列为空但余额不为空，重新构建队列")
            # 按当前余额重新构建队列
            if self.个人余额 > 0:
                self.资金流入队列.append((self.个人余额, '个人', 交易日期))
            if self.公司余额 > 0:
                self.资金流入队列.append((self.公司余额, '公司', 交易日期))
        
        # 按FIFO原则从资金流入队列中扣除
        剩余金额 = 实际扣除金额
        个人扣除 = 0
        公司扣除 = 0
        
        while 剩余金额 > 0 and self.资金流入队列:
            流入金额, 流入类型, 流入时间 = self.资金流入队列.popleft()
            
            if 流入金额 <= 剩余金额:
                # 完全扣除这笔流入
                if 流入类型 == '个人':
                    个人扣除 += 流入金额
                    self.个人余额 = max(0, self.个人余额 - 流入金额)
                else:
                    公司扣除 += 流入金额
                    self.公司余额 = max(0, self.公司余额 - 流入金额)
                剩余金额 -= 流入金额
            else:
                # 部分扣除这笔流入
                if 流入类型 == '个人':
                    个人扣除 += 剩余金额
                    self.个人余额 = max(0, self.个人余额 - 剩余金额)
                    # 将剩余部分重新放回队列
                    self.资金流入队列.appendleft((流入金额 - 剩余金额, '个人', 流入时间))
                else:
                    公司扣除 += 剩余金额
                    self.公司余额 = max(0, self.公司余额 - 剩余金额)
                    # 将剩余部分重新放回队列
                    self.资金流入队列.appendleft((流入金额 - 剩余金额, '公司', 流入时间))
                剩余金额 = 0
        
        # 计算占比（基于原始金额）
        if 原始金额 > 0:
            个人占比 = 个人扣除 / 原始金额
            公司占比 = 公司扣除 / 原始金额
        else:
            个人占比 = 0
            公司占比 = 0
        
        # 分析行为性质
        基础行为性质 = self.行为分析器.分析行为性质(资金属性, 个人扣除, 公司扣除, 原始金额)
        
        # 累加普通交易的挪用/垫付到tracker中（保留投资挪用）
        本次挪用增量 = self.行为分析器.累计挪用金额 - getattr(self, '_上次行为分析器挪用金额', 0)
        本次垫付增量 = self.行为分析器.累计垫付金额 - getattr(self, '_上次行为分析器垫付金额', 0)
        
        self.累计挪用金额 += 本次挪用增量
        self.累计垫付金额 += 本次垫付增量
        
        # 记录当前行为分析器的累计值，用于下次计算增量
        self._上次行为分析器挪用金额 = self.行为分析器.累计挪用金额
        self._上次行为分析器垫付金额 = self.行为分析器.累计垫付金额
        
        # 格式化数值
        self.累计挪用金额 = self.格式化数值(self.累计挪用金额)
        self.累计垫付金额 = self.格式化数值(self.累计垫付金额)
        
        # 添加资金不足的说明
        if 资金缺口 > 0:
            行为性质 = f"{基础行为性质}；资金缺口：{资金缺口:,.2f}"
        else:
            行为性质 = 基础行为性质
        
        return 个人占比, 公司占比, 行为性质
    
    def _处理投资资金流出(self, 金额: float, 资金属性: str, 交易日期: Optional[pd.Timestamp]) -> Tuple[float, float, str]:
        """处理投资资金流出，投资是个人行为，使用公司资金就是挪用"""
        if 金额 <= 0:
            return 0, 0, ""
        
        # 检查是否有足够的资金
        total_available = self.个人余额 + self.公司余额
        if total_available <= 0:
            audit_logger.warning(f"资金池已空，无法支出{金额:,.2f}")
            return 0, 0, "资金池已空"
        
        # 添加误差容忍度，避免浮点数精度问题导致的虚假警告
        资金缺口 = 金额 - total_available
        if 资金缺口 > Config.BALANCE_TOLERANCE:  # 使用0.01元容忍度，避免尾差问题
            audit_logger.warning(f"资金不足! 需要{金额:,.2f}, 可用{total_available:,.2f}，只扣除现有余额")
            金额 = total_available  # 只扣除现有余额
        
        # 按FIFO原则从资金流入队列中扣除
        剩余金额 = 金额
        个人扣除 = 0
        公司扣除 = 0
        
        while 剩余金额 > 0 and self.资金流入队列:
            流入金额, 流入类型, 流入时间 = self.资金流入队列.popleft()
            
            if 流入金额 <= 剩余金额:
                # 完全扣除这笔流入
                if 流入类型 == '个人':
                    个人扣除 += 流入金额
                    self.个人余额 = max(0, self.个人余额 - 流入金额)
                else:
                    公司扣除 += 流入金额
                    self.公司余额 = max(0, self.公司余额 - 流入金额)
                剩余金额 -= 流入金额
            else:
                # 部分扣除这笔流入
                if 流入类型 == '个人':
                    个人扣除 += 剩余金额
                    self.个人余额 = max(0, self.个人余额 - 剩余金额)
                    # 将剩余部分重新放回队列
                    self.资金流入队列.appendleft((流入金额 - 剩余金额, '个人', 流入时间))
                else:
                    公司扣除 += 剩余金额
                    self.公司余额 = max(0, self.公司余额 - 剩余金额)
                    # 将剩余部分重新放回队列
                    self.资金流入队列.appendleft((流入金额 - 剩余金额, '公司', 流入时间))
                剩余金额 = 0
        
        # 计算占比
        total_deducted = 个人扣除 + 公司扣除
        if total_deducted > 0:
            个人占比 = 个人扣除 / total_deducted
            公司占比 = 公司扣除 / total_deducted
        else:
            个人占比 = 0
            公司占比 = 0
        
        # 投资是个人行为，使用公司资金就是挪用
        if 公司扣除 > 0:
            self.累计挪用金额 += 公司扣除
            self.累计挪用金额 = self.格式化数值(self.累计挪用金额)
            
        # 构造行为性质描述
        行为描述 = []
        if 公司扣除 > 0:
            行为描述.append(f"投资挪用：{公司扣除:,.2f}")
        if 个人扣除 > 0:
            行为描述.append(f"个人投资：{个人扣除:,.2f}")
        
        行为性质 = "；".join(行为描述) if 行为描述 else "无投资"
        
        return 个人占比, 公司占比, 行为性质
    
    def _更新投资产品资金池(self, 投资产品编号: str, 金额: float, 个人占比: float, 公司占比: float) -> None:
        """更新投资产品资金池"""
        个人金额 = 金额 * 个人占比
        公司金额 = 金额 * 公司占比
        
        if 投资产品编号 not in self.投资产品资金池:
            # 新建投资产品资金池
            self.投资产品资金池[投资产品编号] = {
                '个人金额': 0, 
                '公司金额': 0, 
                '总金额': 0,
                '累计申购': 0,
                '累计赎回': 0,
                '最新个人占比': 0,
                '最新公司占比': 0
            }
        
        # 检查当前资金池状态
        当前总金额 = self.投资产品资金池[投资产品编号]['总金额']
        
        if 当前总金额 < 0:
            # 资金池为负数，说明之前有收益，再次申购时重置资金池
            # audit_logger.info(f"投资产品{投资产品编号}资金池为负数({当前总金额:,.2f})，重置为新申购")
            self.投资产品资金池[投资产品编号]['个人金额'] = 个人金额
            self.投资产品资金池[投资产品编号]['公司金额'] = 公司金额
            self.投资产品资金池[投资产品编号]['总金额'] = 金额
            # 更新占比记录（与新入资的占比一致）
            self.投资产品资金池[投资产品编号]['最新个人占比'] = 个人占比
            self.投资产品资金池[投资产品编号]['最新公司占比'] = 公司占比
        else:
            # 正常累加新申购金额
            self.投资产品资金池[投资产品编号]['个人金额'] += 个人金额
            self.投资产品资金池[投资产品编号]['公司金额'] += 公司金额
            self.投资产品资金池[投资产品编号]['总金额'] += 金额
            # 更新占比记录（按新的总金额计算）
            新总金额 = self.投资产品资金池[投资产品编号]['总金额']
            if 新总金额 > 0:
                self.投资产品资金池[投资产品编号]['最新个人占比'] = self.投资产品资金池[投资产品编号]['个人金额'] / 新总金额
                self.投资产品资金池[投资产品编号]['最新公司占比'] = self.投资产品资金池[投资产品编号]['公司金额'] / 新总金额
        
        self.投资产品资金池[投资产品编号]['累计申购'] += 金额
        
        # 记录投资产品入金交易
        产品信息 = self.投资产品资金池[投资产品编号]
        个人余额 = 产品信息['个人金额']
        公司余额 = 产品信息['公司金额']
        总余额 = 产品信息['总金额']
        
        # 计算资金占比描述
        if 总余额 > 0:
            个人占比_显示 = f"个人{个人占比:.1%}"
            公司占比_显示 = f"公司{公司占比:.1%}"
            资金占比 = f"{个人占比_显示}，{公司占比_显示}"
        else:
            资金占比 = "无资金"
        
        交易记录 = {
            '资金池名称': 投资产品编号,
            '入金': 金额,
            '出金': 0,
            '总余额': 总余额,
            '个人余额': 个人余额,
            '公司余额': 公司余额,
            '资金占比': 资金占比,
            '行为性质': f"入金（个人{个人金额:,.0f}，公司{公司金额:,.0f}）",
            '累计申购': 产品信息['累计申购'],
            '累计赎回': 产品信息['累计赎回']
        }
        self.投资产品交易记录.append(交易记录)
    
    def 处理投资产品赎回(self, 金额: float, 资金属性: str, 交易日期: Optional[pd.Timestamp]) -> Tuple[float, float, str]:
        """
        处理投资产品赎回，按总体比例返还资金，计算收益和非法所得
        
        Args:
            金额: 赎回金额
            资金属性: 资金属性描述
            交易日期: 交易日期
            
        Returns:
            (个人占比, 公司占比, 行为性质)
        """
        if 金额 <= 0:
            return 0, 0, ""
        
        投资产品编号 = 资金属性
        if not Config.is_investment_product(资金属性):
            return 0, 0, ""
        
        # 查找对应的投资产品记录
        if 投资产品编号 not in self.投资产品资金池:
            # 没有找到对应的投资产品记录，说明没有申购记录，
            # 按照用户要求，这种收入应该算做个人应收来计算
            self.个人余额 += 金额
            self.资金流入队列.append((金额, '个人', 交易日期))
            前缀 = 投资产品编号.split('-')[0]
            return 1.0, 0.0, f"{前缀}收入-{投资产品编号}：个人应收{金额:,.2f}（无申购记录）"
        
        产品信息 = self.投资产品资金池[投资产品编号]
        总金额 = 产品信息['总金额']
        个人金额 = 产品信息['个人金额']
        公司金额 = 产品信息['公司金额']
        累计申购 = 产品信息['累计申购']
        累计赎回 = 产品信息['累计赎回']
        最新个人占比 = 产品信息['最新个人占比']
        最新公司占比 = 产品信息['最新公司占比']
        
        # 检查是否有有效的占比记录
        if 最新个人占比 == 0 and 最新公司占比 == 0:
            return 0, 0, f"错误：投资产品{投资产品编号}从未有过有效资金池，无法分配收益"
        
        # 赎回时统一使用最新记录的占比，不管资金池是正数、0还是负数
        个人返还 = 金额 * 最新个人占比
        公司返还 = 金额 * 最新公司占比
        
        # 计算收益情况和本金归还
        if 总金额 > 0:
            # 按原始逻辑计算赎回比例和收益
            赎回比例 = 金额 / 总金额 if 总金额 > 0 else 0
            对应申购成本 = 总金额 * 赎回比例
            收益 = 金额 - 对应申购成本
            
            # 计算实际归还的本金（不包括收益部分）
            if 金额 <= 总金额:
                # 部分赎回或等额赎回，全部是本金归还
                归还的个人本金 = 个人金额 * 赎回比例
                归还的公司本金 = 公司金额 * 赎回比例
            else:
                # 超额赎回，只有本金部分算作归还
                归还的个人本金 = 个人金额  # 全额归还个人本金
                归还的公司本金 = 公司金额  # 全额归还公司本金
            
            # 按原始逻辑更新投资产品资金池
            self.投资产品资金池[投资产品编号]['个人金额'] -= 个人金额 * 赎回比例
            self.投资产品资金池[投资产品编号]['公司金额'] -= 公司金额 * 赎回比例
            self.投资产品资金池[投资产品编号]['总金额'] -= 对应申购成本
            
            # 记录归还的公司本金（用于抵消挪用）
            if 归还的公司本金 > 0:
                self.累计已归还公司本金 += 归还的公司本金
                self.累计已归还公司本金 = self.格式化数值(self.累计已归还公司本金)
        else:
            # 资金池为0或负数，纯收益分配
            收益 = 金额
            归还的公司本金 = 0  # 纯收益时没有本金归还
            归还的个人本金 = 0
            
            # 更新资金池（继续减少，保持负数状态）
            self.投资产品资金池[投资产品编号]['个人金额'] -= 个人返还
            self.投资产品资金池[投资产品编号]['公司金额'] -= 公司返还
            self.投资产品资金池[投资产品编号]['总金额'] -= 金额
        
        self.投资产品资金池[投资产品编号]['累计赎回'] += 金额
        
        # 收益分配（不再全部算作非法所得）
        if 收益 > 0:
            个人收益 = 收益 * 最新个人占比
            公司收益 = 收益 * 最新公司占比
            # 收益按比例分配，不算作非法所得
            self.总计个人分配利润 += 个人收益
            self.总计个人分配利润 = self.格式化数值(self.总计个人分配利润)
            self.总计公司分配利润 += 公司收益
            self.总计公司分配利润 = self.格式化数值(self.总计公司分配利润)
        else:
            个人收益 = 0
            公司收益 = 0
        
        # 返还到资金池并加入FIFO队列
        if 个人返还 > 0:
            self.个人余额 += 个人返还
            self.资金流入队列.append((个人返还, '个人', 交易日期))
        
        if 公司返还 > 0:
            self.公司余额 += 公司返还
            self.资金流入队列.append((公司返还, '公司', 交易日期))
        
        前缀 = 投资产品编号.split('-')[0]
        
        # 构造行为性质描述
        if 收益 > 0:
            if 最新个人占比 > 0 and 最新公司占比 > 0:
                行为性质 = f"{前缀}赎回-{投资产品编号}：个人{个人返还:,.2f}（本金{归还的个人本金:,.2f}+收益{个人收益:,.2f}），公司{公司返还:,.2f}（本金{归还的公司本金:,.2f}+收益{公司收益:,.2f}），总收益{收益:,.2f}"
            elif 最新个人占比 > 0:
                行为性质 = f"{前缀}赎回-{投资产品编号}：个人{个人返还:,.2f}（本金{归还的个人本金:,.2f}+收益{个人收益:,.2f}），总收益{收益:,.2f}"
            else:
                行为性质 = f"{前缀}赎回-{投资产品编号}：公司{公司返还:,.2f}（本金{归还的公司本金:,.2f}+收益{公司收益:,.2f}），总收益{收益:,.2f}"
        elif 收益 < 0:
            行为性质 = f"{前缀}赎回-{投资产品编号}：个人{个人返还:,.2f}（本金{归还的个人本金:,.2f}），公司{公司返还:,.2f}（本金{归还的公司本金:,.2f}），亏损{abs(收益):,.2f}"
        else:
            行为性质 = f"{前缀}赎回-{投资产品编号}：个人{个人返还:,.2f}（本金{归还的个人本金:,.2f}），公司{公司返还:,.2f}（本金{归还的公司本金:,.2f}），无收益"
        
        # 记录投资产品出金交易
        更新后产品信息 = self.投资产品资金池[投资产品编号]
        更新后个人余额 = 更新后产品信息['个人金额']
        更新后公司余额 = 更新后产品信息['公司金额']
        更新后总余额 = 更新后产品信息['总金额']
        
        # 计算资金占比描述
        if abs(更新后总余额) > 0.01:
            更新后个人占比 = 更新后个人余额 / 更新后总余额
            更新后公司占比 = 更新后公司余额 / 更新后总余额
            个人占比_显示 = f"个人{更新后个人占比:.1%}"
            公司占比_显示 = f"公司{更新后公司占比:.1%}"
            资金占比 = f"{个人占比_显示}，{公司占比_显示}"
        else:
            资金占比 = "资金池清空"
        
        交易记录 = {
            '资金池名称': 投资产品编号,
            '入金': 0,
            '出金': 金额,
            '总余额': 更新后总余额,
            '个人余额': 更新后个人余额,
            '公司余额': 更新后公司余额,
            '资金占比': 资金占比,
            '行为性质': f"出金（个人{个人返还:,.0f}，公司{公司返还:,.0f}，收益{收益:,.0f}）",
            '累计申购': 更新后产品信息['累计申购'],
            '累计赎回': 更新后产品信息['累计赎回']
        }
        self.投资产品交易记录.append(交易记录)
        
        return 最新个人占比, 最新公司占比, 行为性质
    
    def 获取当前资金占比(self) -> Tuple[float, float]:
        """
        获取当前个人和公司资金占比
        
        Returns:
            (个人占比, 公司占比)
        """
        total_balance = self.个人余额 + self.公司余额
        if total_balance == 0:
            return 0, 0
        return self.个人余额 / total_balance, self.公司余额 / total_balance
    
    def 获取状态摘要(self) -> Dict[str, Any]:
        """
        获取追踪器状态摘要
        
        Returns:
            状态摘要字典
        """
        return {
            '个人余额': self.格式化数值(self.个人余额),
            '公司余额': self.格式化数值(self.公司余额),
            '总余额': self.格式化数值(self.个人余额 + self.公司余额),
            '投资产品数量': len(self.投资产品资金池),
            '资金流入队列长度': len(self.资金流入队列),
            '累计挪用金额': self.格式化数值(self.累计挪用金额),
            '累计垫付金额': self.格式化数值(self.累计垫付金额),
            '累计非法所得': self.格式化数值(self.累计非法所得),
            '总计个人分配利润': self.格式化数值(self.总计个人分配利润),
            '总计公司分配利润': self.格式化数值(self.总计公司分配利润),
            '已初始化': self.已初始化
        } 
    
    def 生成投资产品交易记录Excel(self, 文件名: str = "投资产品交易记录.xlsx") -> None:
        """
        生成投资产品交易记录的Excel文件
        
        Args:
            文件名: 保存的Excel文件名
        """
        if not self.投资产品交易记录:
            audit_logger.info("没有投资产品交易记录，跳过Excel生成")
            return
        
        try:
            # 创建DataFrame
            df = pd.DataFrame(self.投资产品交易记录)
            
            # 保存到Excel
            df.to_excel(文件名, index=False, engine='openpyxl')
            audit_logger.info(f"✅ 投资产品交易记录已保存至: {文件名}")
            audit_logger.info(f"📊 共记录 {len(self.投资产品交易记录)} 笔投资产品交易")
            
        except Exception as e:
            audit_logger.error(f"❌ 生成投资产品交易记录Excel失败: {e}")
            # 如果Excel被占用，尝试保存为备用文件名
            try:
                备用文件名 = 文件名.replace('.xlsx', '_备份.xlsx')
                df.to_excel(备用文件名, index=False, engine='openpyxl')
                audit_logger.info(f"✅ 投资产品交易记录已保存至备用文件: {备用文件名}")
            except Exception as e2:
                audit_logger.error(f"❌ 保存备用文件也失败: {e2}") 